<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Constellation</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a14;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    cursor: default;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // --- Config ---
  const DOT_RADIUS = 5;
  const DOT_HIT_RADIUS = 28;
  const CONNECTION_RANGE = 220;
  const INITIAL_DOTS = 40;
  const MAX_DOTS = 120;
  const SPAWN_INTERVAL = 3200;
  const PALETTE = [
    [130, 230, 255],  // soft cyan
    [190, 140, 255],  // violet
    [255, 220, 180],  // warm white
    [255, 160, 220],  // soft pink
    [160, 255, 200],  // mint
  ];

  let W, H, dpr;
  let dots = [];
  let connections = []; // { a: dot, b: dot, progress: 0..1, alpha: 1 }
  let selectedDot = null;
  let mouseX = -1, mouseY = -1;
  let lastSpawn = 0;
  let time = 0;

  // --- Resize ---
  function resize() {
    dpr = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // --- Dot ---
  function createDot(x, y) {
    const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
    return {
      x: x !== undefined ? x : Math.random() * (W - 60) + 30,
      y: y !== undefined ? y : Math.random() * (H - 60) + 30,
      r: DOT_RADIUS + Math.random() * 2,
      color,
      alpha: 0,       // fades in
      fadeIn: true,
      pulseOffset: Math.random() * Math.PI * 2,
      connected: false,
      pulseSync: 0,   // synced pulse phase when connected
    };
  }

  // --- Init dots ---
  for (let i = 0; i < INITIAL_DOTS; i++) {
    const d = createDot();
    d.alpha = 0.6 + Math.random() * 0.4;
    d.fadeIn = false;
    dots.push(d);
  }

  // --- Helpers ---
  function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  function findDot(px, py) {
    let closest = null, closestD = Infinity;
    for (const d of dots) {
      if (d.alpha < 0.15) continue;
      const dd = Math.hypot(d.x - px, d.y - py);
      if (dd < DOT_HIT_RADIUS && dd < closestD) {
        closest = d;
        closestD = dd;
      }
    }
    return closest;
  }

  function hasConnection(a, b) {
    return connections.some(c =>
      (c.a === a && c.b === b) || (c.a === b && c.b === a)
    );
  }

  function addConnection(a, b) {
    if (a === b || hasConnection(a, b)) return;
    if (dist(a, b) > CONNECTION_RANGE) return;
    connections.push({ a, b, progress: 0, alpha: 1 });
    a.connected = true;
    b.connected = true;
    // sync pulse phase
    const syncPhase = time * 1.5;
    a.pulseSync = syncPhase;
    b.pulseSync = syncPhase;
  }

  function disconnectDot(dot) {
    connections = connections.filter(c => c.a !== dot && c.b !== dot);
    dot.connected = false;
    // check if remaining connected dots still have connections
    for (const d of dots) {
      if (d === dot) continue;
      d.connected = connections.some(c => c.a === d || c.b === d);
    }
  }

  // --- Input ---
  let lastTapTime = 0;
  let lastTapDot = null;

  function handleTap(px, py) {
    const dot = findDot(px, py);
    if (!dot) {
      selectedDot = null;
      return;
    }

    const now = performance.now();
    // double-tap detection
    if (dot === lastTapDot && now - lastTapTime < 380) {
      disconnectDot(dot);
      selectedDot = null;
      lastTapDot = null;
      return;
    }
    lastTapTime = now;
    lastTapDot = dot;

    if (selectedDot && selectedDot !== dot) {
      addConnection(selectedDot, dot);
      selectedDot = dot;
    } else if (selectedDot === dot) {
      selectedDot = null;
    } else {
      selectedDot = dot;
    }
  }

  canvas.addEventListener('pointerdown', e => {
    const rect = canvas.getBoundingClientRect();
    handleTap(e.clientX - rect.left, e.clientY - rect.top);
  });

  canvas.addEventListener('pointermove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  });

  canvas.addEventListener('pointerleave', () => {
    mouseX = -1;
    mouseY = -1;
  });

  // prevent context menu on long press
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // --- Draw ---
  function drawGlow(x, y, radius, color, alpha) {
    const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
    grad.addColorStop(0, `rgba(${color[0]},${color[1]},${color[2]},${alpha * 0.5})`);
    grad.addColorStop(1, `rgba(${color[0]},${color[1]},${color[2]},0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawDot(dot, dt) {
    // fade in
    if (dot.fadeIn) {
      dot.alpha += dt * 0.4;
      if (dot.alpha >= 1) {
        dot.alpha = 1;
        dot.fadeIn = false;
      }
    }

    // pulse
    let pulse;
    if (dot.connected) {
      pulse = 0.7 + 0.3 * Math.sin((time * 1.5 - dot.pulseSync) + dot.pulseOffset);
    } else {
      pulse = 0.55 + 0.25 * Math.sin(time * 0.8 + dot.pulseOffset);
    }

    const a = dot.alpha * pulse;
    const r = dot.r * (0.9 + 0.2 * pulse);

    // outer glow
    drawGlow(dot.x, dot.y, r * 6, dot.color, a * 0.3);

    // selected highlight
    if (dot === selectedDot) {
      drawGlow(dot.x, dot.y, r * 10, dot.color, 0.25 + 0.15 * Math.sin(time * 3));
      ctx.strokeStyle = `rgba(${dot.color[0]},${dot.color[1]},${dot.color[2]},${0.5 + 0.3 * Math.sin(time * 3)})`;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.arc(dot.x, dot.y, r * 3, 0, Math.PI * 2);
      ctx.stroke();
    }

    // core dot
    ctx.fillStyle = `rgba(${dot.color[0]},${dot.color[1]},${dot.color[2]},${a})`;
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, r, 0, Math.PI * 2);
    ctx.fill();

    // bright center
    ctx.fillStyle = `rgba(255,255,255,${a * 0.7})`;
    ctx.beginPath();
    ctx.arc(dot.x, dot.y, r * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawConnection(conn, dt) {
    // animate in
    if (conn.progress < 1) {
      conn.progress += dt * 2.2;
      if (conn.progress > 1) conn.progress = 1;
    }

    const { a, b, progress } = conn;
    const mx = a.x + (b.x - a.x) * progress;
    const my = a.y + (b.y - a.y) * progress;

    // blend colors
    const cr = (a.color[0] + b.color[0]) / 2;
    const cg = (a.color[1] + b.color[1]) / 2;
    const cb = (a.color[2] + b.color[2]) / 2;

    const pulse = 0.5 + 0.3 * Math.sin(time * 1.5);
    const lineAlpha = conn.alpha * pulse * 0.7;

    // glow line
    ctx.save();
    ctx.lineCap = 'round';
    ctx.shadowColor = `rgba(${cr},${cg},${cb},${lineAlpha})`;
    ctx.shadowBlur = 12;
    ctx.strokeStyle = `rgba(${cr},${cg},${cb},${lineAlpha})`;
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(mx, my);
    ctx.stroke();
    ctx.restore();

    // brighter core line
    ctx.save();
    ctx.lineCap = 'round';
    ctx.strokeStyle = `rgba(${Math.min(cr + 60, 255)},${Math.min(cg + 60, 255)},${Math.min(cb + 60, 255)},${lineAlpha * 0.6})`;
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(mx, my);
    ctx.stroke();
    ctx.restore();
  }

  function drawPreviewLine() {
    if (!selectedDot || mouseX < 0) return;
    const hoveredDot = findDot(mouseX, mouseY);
    if (!hoveredDot || hoveredDot === selectedDot) return;
    if (dist(selectedDot, hoveredDot) > CONNECTION_RANGE) return;
    if (hasConnection(selectedDot, hoveredDot)) return;

    const a = selectedDot, b = hoveredDot;
    const cr = (a.color[0] + b.color[0]) / 2;
    const cg = (a.color[1] + b.color[1]) / 2;
    const cb = (a.color[2] + b.color[2]) / 2;
    const alpha = 0.15 + 0.1 * Math.sin(time * 4);

    ctx.save();
    ctx.setLineDash([6, 8]);
    ctx.lineCap = 'round';
    ctx.strokeStyle = `rgba(${cr},${cg},${cb},${alpha})`;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    ctx.restore();
  }

  // --- Background stars ---
  const bgStars = [];
  for (let i = 0; i < 200; i++) {
    bgStars.push({
      x: Math.random(),
      y: Math.random(),
      r: Math.random() * 1.2,
      twinkle: Math.random() * Math.PI * 2,
      speed: 0.3 + Math.random() * 0.8,
    });
  }

  function drawBackground() {
    // gradient bg
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#0a0a14');
    grad.addColorStop(0.5, '#0d0d1a');
    grad.addColorStop(1, '#0f0a18');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // twinkling stars
    for (const s of bgStars) {
      const a = 0.2 + 0.35 * Math.sin(time * s.speed + s.twinkle);
      ctx.fillStyle = `rgba(200,210,255,${a})`;
      ctx.beginPath();
      ctx.arc(s.x * W, s.y * H, s.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // --- Spawn dots ---
  function maybeSpawnDot(now) {
    if (now - lastSpawn < SPAWN_INTERVAL) return;
    if (dots.length >= MAX_DOTS) return;
    lastSpawn = now;

    // avoid spawning too close to existing dots
    let attempts = 0;
    while (attempts < 10) {
      const x = Math.random() * (W - 60) + 30;
      const y = Math.random() * (H - 60) + 30;
      let tooClose = false;
      for (const d of dots) {
        if (Math.hypot(d.x - x, d.y - y) < 40) {
          tooClose = true;
          break;
        }
      }
      if (!tooClose) {
        dots.push(createDot(x, y));
        return;
      }
      attempts++;
    }
  }

  // --- Main loop ---
  let lastTime = performance.now();

  function frame(now) {
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    time += dt;

    resize(); // handles dpr changes smoothly
    drawBackground();
    maybeSpawnDot(now);

    // draw connections (behind dots)
    for (const c of connections) {
      drawConnection(c, dt);
    }

    drawPreviewLine();

    // draw dots
    for (const d of dots) {
      drawDot(d, dt);
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
